'''
This module provides a collection of functions that produce the figures used
in the paper
'''

import json
import util
import analysis
import sys
import random
import naive_bayes
import ontology
import data_processing
import numpy as np
import time

try:
	import matplotlib.pyplot as plt
	import matplotlib 
	import matplotlib.gridspec as gridspec
	from matplotlib.ticker import FixedLocator, LinearLocator, FixedFormatter

except:
	print 'matplotlib not installed.  You can do computations but not '\
		'plotting functions.'
	

# z-score for two-tailed 99-percent confidence interval
CONFIDENCE_95 = 1.96
CONFIDENCE_99 = 2.975


TREATMENT_NAMES = {
	'treatment0': 'AMBG'
	, 'treatment1': 'CULT$_{img}$'
	, 'treatment2': 'INGR$_{img}$'
	, 'treatment3': 'INGR$_{fund}$'
	, 'treatment4': 'INGR$_{fund,img}$'
	, 'treatment5': 'CULT$_{fund}$'
	, 'treatment6': 'CULT$_{fund,img}$'
}


def plotAllF1Theta(
		readFname='data/new_data/l1.json',
		writeFname='figs/l1_longitudinal.pdf',
		n=125,
		alpha=0.05
	):

	'''
	Plots the theta value for a naive bayes classifier built to distinguish
	between all the interesting pairings of treatments.  See the manuscript
	in <project-root>/docs/drafts for an explanation of theta.

	This function only plots; the data must first be generated by running
	`computeAllF1Accuracy()`
	'''

	subplotLabels = ['A','B','C', 'D', 'E', 'F', 'G']

	# Read the data from file
	f1scores = json.loads(open(readFname, 'r').read())['img_food_obj']

	# Start a figure 
	figWidth = 8.7 / 2.54 	# conversion from PNAS spec in cm to inches
	figHeight = figWidth * 3.	# a reasonable aspect ratio
	fig = plt.figure(figsize=(figWidth, figHeight))

	# calculate the gridspec.  The width ratios are based on the width of
	# each bar-plot-group, spacing between them, and plot padding
	num_subplots = len(f1scores)
	gs = gridspec.GridSpec(num_subplots, 1)

	width = 0.75
	theta_star = analysis.get_theta_star(n, alpha)

	for i in range(len(f1scores)):

		image_id = 'test%d' % i

		# Unpack the data for this subplot
		Y_F1s = f1scores[image_id]
		X_F1s = range(len(Y_F1s))

		# Convert from accuracy to theta
		Y_thetas = map(lambda t: t*2 - 1, f1scores[image_id])
		X_thetas = map(lambda x: x+width, X_F1s)

		# Make a set of axes.  
		# Manage axis-sharing directives, and whether ytick-labels are visible
		if i == 0:
			ax = plt.subplot(gs[i])
			ax0 = ax
		else:
			ax = plt.subplot(gs[i], sharey=ax0)
			plt.setp(ax.get_yticklabels(), visible=False)


		ax.set_ylabel(r'$\hat{\theta}_{NB}$', size=9)
		theta_series = ax.bar(X_F1s, Y_thetas, width, color='0.25')

		padding = 0.25
		xlims = (-padding, len(Y_thetas) - 1 + width + padding)
		plt.xlim(xlims)

		# Put together intelligible labels for the x-axis
		ax.tick_params(axis='both', which='major', labelsize=9)
		xlabels = [str(i) for i in range(len(f1scores[image_id]))]
		ax.set_xticks(map(lambda x: x + width/2., X_F1s))
		ax.set_xticklabels(xlabels, rotation=45, size=9,
			horizontalalignment='right')

		zero = ax.plot(
			xlims, [0, 0], color='0.35', linestyle='-', zorder=0)

		significance_bar = ax.plot(
			xlims, [theta_star, theta_star], color='0.55', linestyle=':')

		# Tighten up the layout
		plt.draw()
		if i < 1:
			plt.tight_layout()

	# After plots are made, put labels along the top.  This needs to wait
	# until now so that the axes limits are stable
	for i, (ax, subplotData) in enumerate(zip(fig.axes, f1scores)):

		pass
		#** put the test task name as an inset


#		# Label the basis treatments above the subplots
#		basisTreatment = subplotData['basis']
#		basisTreatmentName = TREATMENT_NAMES[basisTreatment]
#		left = len(subplotData['accuracy'])/2.0 + width - 2*padding
#		ylims = plt.ylim()
#
#		# put the label directly above the plot.  
#		# The first label needs to be put a bit higher.
#		height= ylims[1] + (0.02 if i else 0.06)
#		ax.text(left, height, basisTreatmentName, 
#				va='bottom', ha='right', size=9, rotation=-45)


	#y_low, y_high = plt.ylim()
	#plt.ylim(-0.09, y_high)

	fig.subplots_adjust(wspace=0.05, top=0.77, right=0.97, left=0.09, 
		bottom=0.24)
	plt.draw()

	fig.savefig(writeFname)
	plt.show()
